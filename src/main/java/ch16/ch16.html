<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ch17 Notes</title>
</head>
<body>
	<h2>第16章 多线程</h2>
	<p>本章重点介绍</p>
	<h3>16.1 </h3>
	<h3>16.2 线程的创建和启动</h3>
		<h4>16.2.3 使用Callable和Future创建线程</h4>
		<p>
		我们可以把Callable接口看做Runnable接口的增强版。和Runnable接口相比，Callable接口中的call方法比Runnable接口中的run方法功能更强大：
		<ul>
			<li>call()可以有返回值</li>
			<li>call()可以声明抛出异常</li>
		</ul>
		Java 5提供了Future接口来表示Callable接口里call()方法的返回值，并为Future接口提供了FutureTask这个实现类，而且该类还实现了Runnable接口，
		---所以，可以作为Thread类的target
		</p>
	<h3>16.3 线程的生命周期</h3>
	 Java中线程有五种状态：新建、就绪、运行、阻塞、死亡
	<h3>16.4 控制线程</h3>
		<h4>16.4.1 join()</h4>
		<p>Thread中提供了让一个线程等待另一个线程完成的方法--join()方法。
		当在某个执行流中调用了其他线程的join方法时，该执行流将阻塞，直到被join()方法加入的线程执行完毕为止</p>
		<p>join()方法通常由使用线程的程序调用，将一个大问题分解为许多小问题，每个小问题分解为一个线程，
		当所有小问题解决后，在调用主线程来进一步处理，这样任务就完成了。（分而治之）</p>
		<p>当然，join还提供了带时间参数的重载形式，代表最多等待多长多长时间，如果在这段时间内，join进来的线程还没执行完，也不再等待</p>
		<h4>16.4.2 后台线程</h4>
		<p>也被成为“守护线程”或者“精灵线程”，它的任务是为其他的线程提供服务。JVM的垃圾回收线程就是典型的后台线程</p>
		<p>后台线程有一个特征：当所有的前台线程死亡后，后台线程会自动死亡。(因为它的职责本来就是为前台线程服务的，前台线程都没有了，它也就没有存在的必要了)</p>
		<h4>16.4.3 sleep() 线程暂停</h4>
		<h4>16.4.4 线程让步：yield()</h4>
			<p>yield()只是将当前线程从执行状态变为就绪状态，意思是向操作系统礼貌性的表示一下，请看一看有没有其它线程需要现在执行啊，您请重新调度一下。</p>
			<p>实际上，当前线程调用yield()表示出让执行时间片后，只有线程优先级与当前线程相同或者更高的线程才会获得执行的时间片</p>
			<p>yield()方法的执行其实依赖具体操作系统的调度策略，所以，并不拥有良好的可移植性</p>
		<h4>16.4.5 改变线程的优先级</h4>
			<p>高优先级的线程理论上拥有更多的执行机会。每个新建线程的优先级默认与创建它的父线程相同，
			使用线程对象的setPriority()方法可以改变线程的优先级</p>
	<h3>16.5 线程同步(*重点*)</h3>
</body>
</html>