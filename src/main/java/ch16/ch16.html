<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ch17 Notes</title>
</head>
<body>
	<h2>第16章 多线程</h2>
	<p>本章重点介绍</p>
	<h3>16.1 </h3>
	<h3>16.2 线程的创建和启动</h3>
		<h4>16.2.3 使用Callable和Future创建线程</h4>
		<p>
		我们可以把Callable接口看做Runnable接口的增强版。和Runnable接口相比，Callable接口中的call方法比Runnable接口中的run方法功能更强大：
		<ul>
			<li>call()可以有返回值</li>
			<li>call()可以声明抛出异常</li>
		</ul>
		Java 5提供了Future接口来表示Callable接口里call()方法的返回值，并为Future接口提供了FutureTask这个实现类，而且该类还实现了Runnable接口，
		---所以，可以作为Thread类的target
		</p>
	<h3>16.3 线程的生命周期</h3>
	 Java中线程有五种状态：新建、就绪、运行、阻塞、死亡
	<h3>16.4 控制线程</h3>
		<h4>16.4.1 join()</h4>
		<p>Thread中提供了让一个线程等待另一个线程完成的方法--join()方法。
		当在某个执行流中调用了其他线程的join方法时，该执行流将阻塞，直到被join()方法加入的线程执行完毕为止</p>
		<p>join()方法通常由使用线程的程序调用，将一个大问题分解为许多小问题，每个小问题分解为一个线程，
		当所有小问题解决后，在调用主线程来进一步处理，这样任务就完成了。（分而治之）</p>
		<p>当然，join还提供了带时间参数的重载形式，代表最多等待多长多长时间，如果在这段时间内，join进来的线程还没执行完，也不再等待</p>
		<h4>16.4.2 后台线程</h4>
		<p>也被成为“守护线程”或者“精灵线程”，它的任务是为其他的线程提供服务。JVM的垃圾回收线程就是典型的后台线程</p>
		<p>后台线程有一个特征：当所有的前台线程死亡后，后台线程会自动死亡。(因为它的职责本来就是为前台线程服务的，前台线程都没有了，它也就没有存在的必要了)</p>
		<h4>16.4.3 sleep() 线程暂停</h4>
		<h4>16.4.4 线程让步：yield()</h4>
			<p>yield()只是将当前线程从执行状态变为就绪状态，意思是向操作系统礼貌性的表示一下，请看一看有没有其它线程需要现在执行啊，您请重新调度一下。</p>
			<p>实际上，当前线程调用yield()表示出让执行时间片后，只有线程优先级与当前线程相同或者更高的线程才会获得执行的时间片</p>
			<p>yield()方法的执行其实依赖具体操作系统的调度策略，所以，并不拥有良好的可移植性</p>
		<h4>16.4.5 改变线程的优先级</h4>
			<p>高优先级的线程理论上拥有更多的执行机会。每个新建线程的优先级默认与创建它的父线程相同，
			使用线程对象的setPriority()方法可以改变线程的优先级</p>
	<h3>16.5 线程同步(*重点*)</h3>
	<h4>16.5.2 使用同步监视器和同步代码块来实现线程安全</h4>
		<p>意思是线程在开始执行同步代码块时，必须先获取对同步监视器的锁定。（所以，通常，这个同步监视器对象就是多个线程将要同时操作的对象）</p>
		<p>任何时候只能有一个线程获得对同步监视器的锁定，当同步代码块执行完毕时，该线程自动释放对同步监视器的锁定</p>
	<h4>16.5.3 使用同步方法来实现线程安全</h4>
		<p>其实就是将this，也就是调用这个同步方法块的对象当做了同步监视器。</p>
	<h4>16.5.4 </h4>
		<p><b>当前线程如果在执行同步代码块或者同步方法时调用了同步监视器的wait()方法，则当前线程会暂停并且释放同步监视器</b></p>
	<h4>16.5.5 同步锁</h4>
		<p>Java 5开始提供了功能更为强大的线程同步机制--同步锁，也就是通过显式定义同步锁对象来实现同步。在这种机制下，同步锁由Lock对象充当</p>
		<p>Lock提供了更加强大、更加灵活的结构。有各种类型的锁，像读写锁、可重入锁等等。可以用来精确的控制对多个线程的共享资源的访问限制</p>
		<p>Java的同步锁有两个根接口：Lock（锁）和ReadWriteLock（读写锁）。
		Java为Lock提供了ReentrantLock（可重入锁）实现类，为ReadWriteLock提供了ReentrantReadWriteLock（可重入读写锁）实现类</p>
		<p>在线程安全操作中，比较常用的锁是ReentrantLock（可重入锁）。使用该类型锁可以显式的进行加锁、释放锁</p>
		<p>ReentrantLock具有可重入性，也就是说，一段被锁保护的代码可以调用另一个被相同锁保护的方法</p>
	<h4>16.5.6 死锁</h4>
		<p>当两个线程互相等待对方释放同步监视器时就会引发死锁，Java虚拟机不会采取措施来处理死锁。（现代操作系统也一样）</p>
	<h4>16.6 线程通信</h4>
	三个方法：wait()、notify()、notifyAll()
	<p>wait()导致当前线程等待，直到其他线程调用该同步监视器的notify()或者notifyAll()方法来唤醒该线程</p>
	<p>notify()或者notifyAll()方法唤醒在此同步监视器上等待的线程</p>
</body>
</html>