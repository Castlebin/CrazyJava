<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ch18 Notes</title>
</head>
<body>
	<h2>第18章 类加载机制与反射</h2>
	<p>本章重点介绍java.lang.reflect包下的接口和类，包括Class、Method、Field、Constructor和Array等。
	这些类分别代表类、方法、成员变量、构造器和数组。
	Java程序可以使用这些类动态的获取某个对象、某个类的运行时信息，并可以动态的创建Java对象，动态的调用方法，访问并修改指定对象的成员变量的值。
	该包下还包含Type和ParameterizedType两个接口，其中Type是Class类所实现的接口，而ParameterizedType类则代表一个带泛型参数的类型，它继承了Type类。</p>
	<h3>18.1 类的加载、连接和初始化</h3>
	<h3>18.2 类加载器</h3>
	<h3>18.3 通过反射查看类信息</h3>
	<h3>18.4 使用反射生成并操作对象</h3>
	<h3>18.5 使用反射生成JDK动态代理</h3>
	<p>在Java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和接口可以生成JDK动态代理类或动态代理对象。</p>
	<p>1. Proxy类提供了
		static Class&lt?&gt getProxyClass(ClassLoader loader, Class&lt?&gt... interfaces)方法来创建动态代理类的Class对象</p>
	<p>2. Proxy类提供了
		static Object newProxyInstance(ClassLoader loader, Class&lt?&gt...interface, InvocationHander handler)方法
	来直接创建一个动态代理对象，执行代理对象的每个方法时都会被替换为执行handler对象的invoke方法</p>
	<ol>
		<li>JDK只支持为接口创建动态代理。可以为一个或多个接口动态的生成实现类和实例</li>
		<li>每创建一个静态代理对象，就必须为其指定一个InvocationHandler对象，执行代理对象的方法时，
			都会自动替换为执行该InvocationHandler对象的invoke方法</li>
	</ol>
	<h3>18.6 反射和泛型</h3>
	<p>从JDK 5开始，Java的Class类增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class其实是Class&ltString&gt。
		如果Class对应的类型暂时未知，则使用Class&lt?&gt。在反射中使用泛型，可以避免使用反射生成对象时需要强制类型转换</p>
	<h3>18.7 本章小结</h3>
</body>
</html>